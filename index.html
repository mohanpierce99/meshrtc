<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <input id="roomtxt" type="text" placeholder="Enter room" autofocus="on">
    <button id="roombtn">ENTER</button>
    <button id="roomext">EXIT</button>
    <video controls width="400" height="400">
        <source src="inter.mp4" type="video/mp4">
    </video>
    <h4>Online users in room : <span id="live"></span></h4>
    <h3>Unique ID</h3>
    <h4 class="head"></h4>
    <h4>Messages : Peer to peer chat</h4>
    <input id="sendm" type="text">
    <button id="send">Send</button>
    <span id="conn">Connected to : </span>
    <div id="wrapper">

    </div>

    <div id="wrapper1">

    </div>

    <script src="/peermin.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        var vid = document.querySelector("video");
        var room;
        var gate = true;
        var manover = false;
        var seeked = false;
        var socket = io.connect(window.location.origin);
        const AudioContext = window.AudioContext ||
            window.webkitAudioContext;
        let context = new AudioContext();



        function deletePeerData(peerid, mypeers) {
            console.log(peerid,mypeers.filter(x => x.peer != peerid),"checkyu");
            return mypeers.filter(x => x.peer != peerid);
        }



        socket.on('connect', () => {
            console.log("Connected");
            document.querySelector("#roombtn").addEventListener('click', () => {
                var room = document.querySelector("#roomtxt").value;

                if (socket.room) {
                    messages.innerHTML = "";
                    socket.emit('leaving', {
                        peerid: peer.id
                    });
                }

                socket.emit("joinRoom", room);

                console.log("Server:controls");

                socket.on("roomJoinSuccess", () => {
                    console.log("Room joined");
                    var peer = new Peer({
                        host: "peerjs-server-api.herokuapp.com",
                        path: "/peer",
                        secure: true,
                        port: 443,
                        config: {
                            'iceServers': [{
                                url: 'stun:stun1.l.google.com:19302'
                            }]
                        }
                    });
                    var callStreams = [];
                    var mypeers = [];


                    peer.on("connection", (c) => {
                        sel("#conn").innerHTML += c.peer + ",";
                        //PUSH CONN TO CONN LIST FINALLY
                        mypeers=deletePeerData(c.peer, mypeers);
                        mypeers.push(c);
                        console.log(c);
                        console.log("pushed");
                        c.on('data', function (data) {
                            console.log("hit");
                            inject(newchip(`Peer message, ${data}`));
                        });
                        callPeer(c.peer);
                    });

                    peer.on('open', (id) => {
                        console.log("id generated");
                        peer.id = id;
                        sel(".head").innerHTML = id;
                        socket.emit('signal', {
                            peerid: peer.id
                        });
                    });

                    function callPeer(id) { //call skype
                        navigator.mediaDevices.getUserMedia({
                            audio: true
                        }).then(stream => {
                            callStreams.push(stream);
                            console.log(id + "call", stream);
                            var call = peer.call(id, stream);
                            var callpeer = mypeers.filter(x => x.peer == call.peer)[0];
                            if (callpeer) {
                                callpeer.call = call;
                                console.log("call object injected");
                            }
                            call.on('stream', (stream) => {
                                console.log("received stream answered");
                                var audio = document.createElement("audio");
                                audio.srcObject = stream;
                                audio.style.display = "none";
                                sel("#wrapper").appendChild(audio);
                                audio.play();
                            });
                        });

                    }

                    peer.on('call', function (call) {
                        var callpeer = mypeers.filter(x => x.peer == call.peer)[0];
                        if (callpeer) {
                            callpeer.call = call;
                            console.log("call object injected after receiuvingli");
                        }
                        navigator.mediaDevices.getUserMedia({
                            audio: true
                        }).then(stream => {
                            callStreams.push(stream);
                            inject(newchip("call received"));
                            call.answer(stream);
                            call.on('stream', function (stream) {
                                console.log("received stream");
                                var audio = document.createElement(
                                    "audio");
                                audio.srcObject = stream;
                                audio.style.display = "none";
                                sel("#wrapper").appendChild(audio);
                                audio.play();
                            });
                        });
                    });


                    peer.on('data', function (data) {
                        console.log("hittedma");
                        inject(newchip(`! Peer message, ${data}`));
                    });
                    socket.on("signal", (d) => {
                        console.log(d + "signalled");
                        if (d.peerid == peer.id) {
                            console.log("hit oops");
                            return;
                        }
                        var conn = peer.connect(d.peerid, {
                            reliable: true
                        });
                        console.log("peer added");
                        conn.on('open', function () {
                            console.log("connectedtopeer");
                            console.log(conn);
                            mypeers.push(conn);
                            console.log("pushed to no of peers");
                            sel("#conn").innerHTML += conn.peer + ",";
                            conn.on('data', function (data) {
                                console.log("hittedma");
                                inject(newchip(
                                    `Peer message, ${data}`));
                            });
                        });
                    });

                    sel("#send").addEventListener("click", () => {
                        let data = sel("#sendm").value;
                        inject(newchip(data));
                        mypeers.forEach((p) => {
                            p.send(data);
                            console.log("Sent data to" + p.peer);
                        });
                    });

                    sel("#roomext").addEventListener('click', () => {
                        mypeers.forEach(x => {
                            x.call.close();
                            x.close();
                        });
                        callStreams.forEach(micstream => {
                            micstream.getTracks().forEach(x => x.stop());
                        });
                        socket.emit('leaving', {
                            peerid: peer.id
                        });
                    });

                    vid.addEventListener("pause", () => {
                        if (manover || seeked) {
                            manover = false;
                            seeked = false;
                            return;
                        }
                        socket.emit("controls", {
                            action: "pause",
                            id: socket.id,
                            room,
                            currentTime: vid.currentTime
                        });
                    });
                    vid.addEventListener("play", () => {
                        if (manover) {
                            manover = false;
                            return;
                        }
                        if (seeked)
                            seeked = false;
                        socket.emit("controls", {
                            action: "play",
                            id: socket.id,
                            room,
                            currentTime: vid.currentTime
                        });
                    });

                    socket.on('userstat', function (data) {
                        console.log(data.usercount);
                        sel("#live").innerHTML = data.usercount
                    });

                    //DELETE LEFT USER FROM PEERSLIST
                    socket.on('newLeaving', function (data) {
                        console.log(mypeers);
                        mypeers.filter(x =>{console.log(x.peer,data.leftPeerid); return x.peer == data.leftPeerid})[0].call.close();
                        mypeers=deletePeerData(data.leftPeerid, mypeers);
                        console.log(mypeers);
                        console.log(`${data.leftPeerid} LEFT THE ROOM`);
                        console.log("dfjdkgfj", mypeers.filter(x => x.peer == data
                            .leftPeerid)[0]);
                        console.log(mypeers);
                    });
                });
                vid.addEventListener("seeked", () => {
                    if (manover) {
                        manover = false;
                        return;
                    }
                    console.log("seeked");
                    socket.emit("controls", {
                        action: "seek",
                        seektime: vid.currentTime,
                        id: socket.id,
                        room
                    })
                });
                socket.on("controlUpdate", (obj) => {
                    if (obj.id === socket.id)
                        return;
                    console.log(obj);
                    if (obj.action === "play") {
                        manover = true;
                        vid.currentTime = obj.currentTime;
                        vid.play().catch();
                    }
                    if (obj.action === "pause") {
                        manover = true;
                        vid.currentTime = obj.currentTime;
                        vid.pause();
                    }
                    if (obj.action === "seek") {
                        manover = true;
                        seeked = true;
                        vid.currentTime = obj.seektime;
                    }
                });
            });

        })

        function newchip(d) {
            let temp = document.createElement("p");
            temp.innerHTML = d;
            return temp;
        }

        function inject(el, data) {
            let area = sel(data || "#wrapper");
            area.appendChild(el);
            return;
        }

        function sel(d) {
            return document.querySelector(d);
        }

        function error() {}
    </script>

</body>

</html>